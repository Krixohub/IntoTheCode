---
Title: Documentaion
---
<!-- This is a generated file. Dont edit! -->

### <a name="IntoTheCode.CodeElement">Class: CodeElement</a>
(Namespace: IntoTheCode)

Inherits [IntoTheCode.TextElement](#IntoTheCode.TextElement)
    <br>*The Elements that is read as part of a syntax.*
    

### <a name="IntoTheCode.Parser">Class: Parser</a>
(Namespace: IntoTheCode)
<br>*Read text according to a grammar. The parser holds the parser elements to read a code. Parser = a program that reads code, acording to a grammar. ParserElement = an element of a program that reads code elements, acording to a syntax element.*
    
**Property: Name**
<br>*Name of grammar; The name of the first rule.*
    
**Property: Rules**
<br>*Property for parser elements.*
    
**Constructor(System.String)**
    
* Parameter Grammar: Create parser for proces Grammar definition. If empty a meta Grammar is created.<br>*Create parser.*
    
**Function: GetGrammar()**
    
* Returns: A grammar.<br>*Get formatted grammar for this parser.*
    

### <a name="IntoTheCode.CodeDocument">Class: CodeDocument</a>
(Namespace: IntoTheCode)

Inherits [IntoTheCode.TextElement](#IntoTheCode.TextElement)
    <br>*Represents a code document.*
    
**Function: Load(IntoTheCode.Parser,System.String)**
    
* Parameter parser: 
* Parameter input: 
* Returns: <br>*Parse code with a given parser.*
    
**Function: GetValue()**
    
**Function: ToMarkup(System.Boolean)**
    
* Parameter xmlEncode: Encode the values to xml.
* Returns: A string of markup.<br>*Transform document to markup.*
    

### <a name="IntoTheCode.Basic.Layer.NotifyChanges">Class: NotifyChanges</a>
(Namespace: IntoTheCode.Basic.Layer)
<br>*Baseclass to implement INotifyPropertyChanged.*
    
**Function: RaisePropertyChanged(System.Linq.Expressions.Expression{System.Func{System.Object}})**
    
* Parameter exp: Lambda expression. Feks ()=&gt;PropertyName.<br>*Raise PropertyChanged when a property is changed.*
    
**Function: RaisePropertyChanged(System.String)**
    
* Parameter name: Name of changed property.<br>*Raise PropertyChanged with string.*
    

### <a name="IntoTheCode.Basic.TreeNode`1">Class: TreeNode`1</a>
(Namespace: IntoTheCode.Basic)
<br>*A Element has a parent, a string value (text) and a set of sub elements.*
    
**Property: Name**
<br>*Property for name.*
    
**Property: Parent**
<br>*Property for parent element.*
    
**Property: ChildNodes**
<br>*Property for sub elements (elements).*
    
**Function: GetValue()**
    
* Returns: The text value.<br>*Get the text of this node.*
    
**Function: Nodes(System.String)**
    
* Parameter name: The name to search for.
* Returns: A enumerable of elements.<br>*Find sub elements with a given name.*
    
**Function: Nodes(System.Func{`0,System.Boolean})**
    
* Parameter predicate: The predicate to filter with.
* Returns: A enumerable of elements.<br>*Find sub elements with a predicate.*
    
**Function: AnyNested(System.Func{`0,System.Boolean})**
    
* Parameter predicate: The predicate.
* Returns: A enumerable of elements.<br>*Find sub elements with a predicate.*
    

### <a name="IntoTheCode.Buffer.FlatBuffer">Class: FlatBuffer</a>
(Namespace: IntoTheCode.Buffer)

Inherits [IntoTheCode.Buffer.TextBuffer](#IntoTheCode.Buffer.TextBuffer)
    

### <a name="IntoTheCode.Read.Structure.Expression">Class: Expression</a>
(Namespace: IntoTheCode.Read.Structure)

Inherits [IntoTheCode.Read.Structure.Or](#IntoTheCode.Read.Structure.Or)
    <br>*Expressions read strings like this 'a + b * - c * ( 2 + d )' (Infix notation). The expression rule must look like this "expr = mul | sum | value". Or like this (inline) : "expr = expr '*' expr | value;". It is a list of alternatives. The first alternative must be a binary operator. At least one alternative must be something else; not recursive. The binary operator rules must have this form: "sum = expr '+' expr". Where '+' is the operator. The default precedence are determined by the order of the operators in the expression rule. First operator has highest precedence. The operator precedence can be changed by setting the 'precedence' property. Operators are default left associative. If an operator is right associative set the 'RightAssociative' property. Output: The output tree is nested operator elements; An operator has to values elements. A value elements can be a new operator element or one of the other alternatives.*
    
**Constructor(IntoTheCode.Read.Structure.Rule,IntoTheCode.Read.Structure.Or)**
    <br>*Create the Expression from the alternatives in an Or object.*
    
**Function: SetPrecedence()**
    <br>*Set precedence for binary operators. Operators with precendence set are ordered by this. Operators without precedence are ordered according to the position in syntax.*
    
**Function: GetSettings(System.Collections.Generic.List{System.Tuple{System.String,System.String}})**
    
* Parameter settings: <br>*Get Precedence and 'RightAssociative' for operators.*
    
**Function: LoadValue(System.Collections.Generic.List{IntoTheCode.TextElement},System.Int32,System.Boolean)**
    
* Parameter operations: The value is added to this list.
* Parameter level: Level of rule links.
* Returns: True if succes.<br>*Load a value. Inclusive const, variables and unary operators.*
    
**Function: LoadBinaryOperator(System.Collections.Generic.List{IntoTheCode.TextElement},System.Int32)**
    
* Parameter outElements: The value is added to this list.
* Parameter level: Level of rule links.
* Returns: True if succes.<br>*Load a binary operator.*
    
**Function: ResolveErrorsLast(IntoTheCode.CodeElement,System.Int32)**
    
* Returns: 0: Not found, 1: Found-read error, 2: Found and read ok.
**Function: ResolveErrorsForwardValue(System.Int32,System.Boolean)**
    
* Parameter operations: The value is added to this list.
* Parameter level: Level of rule links.
* Returns: True if succes.<br>*ResolveErrorsForward a value. Inclusive const, variables and unary operators.*
    
**Function: ResolveErrorsForwardBinaryOperator(System.Int32)**
    
* Parameter outElements: The value is added to this list.
* Parameter level: Level of rule links.
* Returns: True if succes.<br>*ResolveErrorsForward a binary operator.*
    

### <a name="IntoTheCode.Read.Structure.SetOfElements">Class: SetOfElements</a>
(Namespace: IntoTheCode.Read.Structure)

Inherits [IntoTheCode.Read.Structure.SetOfElementsBase](#IntoTheCode.Read.Structure.SetOfElementsBase)
    
**Constructor(IntoTheCode.Read.ParserElementBase[])**
    <br>*Creator for .*
    
**Function: ResolveErrorsLast(IntoTheCode.CodeElement,System.Int32)**
    
* Returns: 0: Not found, 1: Found-read error, 2: Found and read ok.

### <a name="IntoTheCode.Read.Structure.SetOfElementsBase">Class: SetOfElementsBase</a>
(Namespace: IntoTheCode.Read.Structure)

Inherits [IntoTheCode.Read.ParserElementBase](#IntoTheCode.Read.ParserElementBase)
    
**Constructor()**
    <br>*To create unlinked Grammar.*
    
**Function: ResolveSetErrorsLast(IntoTheCode.CodeElement,System.Int32)**
    
* Parameter last: Not null, not empty.
* Returns: 0: Not found, 1: Found-read error, 2: Found and read ok.<br>*Find the Rule/ 'read element', that correspond to the last CodeElement, and read it again with error resolving. If no error, try to read further.*
    

### <a name="IntoTheCode.Read.Structure.Rule">Class: Rule</a>
(Namespace: IntoTheCode.Read.Structure)

Inherits [IntoTheCode.Read.Structure.SetOfElementsBase](#IntoTheCode.Read.Structure.SetOfElementsBase)
    
**Constructor(System.String,IntoTheCode.Read.ParserElementBase[])**
    
* Parameter name: 
* Parameter elements: <br>*Statement, Action,*
    
**Function: ResolveErrorsLast(IntoTheCode.CodeElement,System.Int32)**
    
* Parameter last: Not null, not empty.
* Returns: 0: Not found, 1: Found-read error, 2: Found and read ok.<br>*Find the Rule/ 'read element', that correspond to the last CodeElement, and read it again with error resolving. If no error, try to read further.*
    

### <a name="IntoTheCode.Read.Structure.Optional">Class: Optional</a>
(Namespace: IntoTheCode.Read.Structure)

Inherits [IntoTheCode.Read.Structure.SetOfElementsBase](#IntoTheCode.Read.Structure.SetOfElementsBase)
    
**Constructor(IntoTheCode.Read.ParserElementBase[])**
    <br>*Creator for .*
    
**Function: ResolveErrorsLast(IntoTheCode.CodeElement,System.Int32)**
    
* Parameter last: Not null, not empty.
* Returns: 0: Not found, 1: Found-read error, 2: Found and read ok.<br>*Find the Rule/ 'read element', that correspond to the last CodeElement, and read it again with error resolving. If no error, try to read further.*
    

### <a name="IntoTheCode.Read.Structure.Or">Class: Or</a>
(Namespace: IntoTheCode.Read.Structure)

Inherits [IntoTheCode.Read.ParserElementBase](#IntoTheCode.Read.ParserElementBase)
    
**Constructor(IntoTheCode.Read.ParserElementBase,IntoTheCode.Read.ParserElementBase)**
    <br>*Creator for .*
    
**Function: ResolveErrorsLast(IntoTheCode.CodeElement,System.Int32)**
    
* Returns: 0: Not found, 1: Found-read error, 2: Found and read ok.

### <a name="IntoTheCode.Read.Structure.Parentheses">Class: Parentheses</a>
(Namespace: IntoTheCode.Read.Structure)

Inherits [IntoTheCode.Read.Structure.SetOfElements](#IntoTheCode.Read.Structure.SetOfElements)
    
**Constructor(IntoTheCode.Read.ParserElementBase[])**
    <br>*Creator for .*
    

### <a name="IntoTheCode.Read.Structure.Sequence">Class: Sequence</a>
(Namespace: IntoTheCode.Read.Structure)

Inherits [IntoTheCode.Read.Structure.SetOfElementsBase](#IntoTheCode.Read.Structure.SetOfElementsBase)
    
**Constructor(IntoTheCode.Read.ParserElementBase[])**
    <br>*Creator for .*
    
**Constructor()**
    <br>*To create an unlinked Grammar.*
    
**Function: ResolveErrorsLast(IntoTheCode.CodeElement,System.Int32)**
    
* Returns: 0: Not found, 1: Found-read error, 2: Found and read ok.

### <a name="IntoTheCode.Read.Structure.RuleLink">Class: RuleLink</a>
(Namespace: IntoTheCode.Read.Structure)

Inherits [IntoTheCode.Read.ParserElementBase](#IntoTheCode.Read.ParserElementBase)
    <br>*Base class for Grammar symbols.*
    
**Constructor(System.String)**
    <br>*Creator for .*
    
**Function: ResolveErrorsLast(IntoTheCode.CodeElement,System.Int32)**
    
* Returns: 0: Not found, 1: Found-read error, 2: Found and read ok.

### <a name="IntoTheCode.Read.Words.WordBinaryOperator">Class: WordBinaryOperator</a>
(Namespace: IntoTheCode.Read.Words)

Inherits [IntoTheCode.Read.Words.WordSymbol](#IntoTheCode.Read.Words.WordSymbol)
    
**Constructor(IntoTheCode.Read.Words.WordSymbol,System.String,IntoTheCode.Buffer.TextBuffer)**
    <br>*Creator for .*
    

### <a name="IntoTheCode.Read.Words.WordFloat">Class: WordFloat</a>
(Namespace: IntoTheCode.Read.Words)

Inherits [IntoTheCode.Read.Words.WordBase](#IntoTheCode.Read.Words.WordBase)
    
**Function: ResolveErrorsLast(IntoTheCode.CodeElement,System.Int32)**
    
* Returns: 0: Not found, 1: Found-read error, 2: Found and read ok.

### <a name="IntoTheCode.Read.Words.WordInt">Class: WordInt</a>
(Namespace: IntoTheCode.Read.Words)

Inherits [IntoTheCode.Read.Words.WordBase](#IntoTheCode.Read.Words.WordBase)
    
**Function: ResolveErrorsLast(IntoTheCode.CodeElement,System.Int32)**
    
* Returns: 0: Not found, 1: Found-read error, 2: Found and read ok.

### <a name="IntoTheCode.Read.Words.WordIdent">Class: WordIdent</a>
(Namespace: IntoTheCode.Read.Words)

Inherits [IntoTheCode.Read.Words.WordBase](#IntoTheCode.Read.Words.WordBase)
    
**Function: ResolveErrorsLast(IntoTheCode.CodeElement,System.Int32)**
    
* Returns: 0: Not found, 1: Found-read error, 2: Found and read ok.

### <a name="IntoTheCode.Read.Words.WordString">Class: WordString</a>
(Namespace: IntoTheCode.Read.Words)

Inherits [IntoTheCode.Read.Words.WordBase](#IntoTheCode.Read.Words.WordBase)
    
**Function: ResolveErrorsLast(IntoTheCode.CodeElement,System.Int32)**
    
* Returns: 0: Not found, 1: Found-read error, 2: Found and read ok.

### <a name="IntoTheCode.Read.Words.WordBase">Class: WordBase</a>
(Namespace: IntoTheCode.Read.Words)

Inherits [IntoTheCode.Read.ParserElementBase](#IntoTheCode.Read.ParserElementBase)
    <br>*A Grammar element that can read charecters (a word).*
    
**Function: GetWord(IntoTheCode.Buffer.TextSubString)**
    
* Parameter buf: 
* Parameter ptr: 
* Returns: <br>*Get string representation of value from buffer.*
    

### <a name="IntoTheCode.Read.Words.WordBool">Class: WordBool</a>
(Namespace: IntoTheCode.Read.Words)

Inherits [IntoTheCode.Read.Words.WordBase](#IntoTheCode.Read.Words.WordBase)
    
**Function: ResolveErrorsLast(IntoTheCode.CodeElement,System.Int32)**
    
* Returns: 0: Not found, 1: Found-read error, 2: Found and read ok.

### <a name="IntoTheCode.Read.Words.WordSymbol">Class: WordSymbol</a>
(Namespace: IntoTheCode.Read.Words)

Inherits [IntoTheCode.Read.Words.WordBase](#IntoTheCode.Read.Words.WordBase)
    
**Property: Precedence**
<br>*Only if this symbol is transformed to an binary operator.*
    
**Property: RightAssociative**
<br>*Only if this symbol is transformed to an binary operator.*
    
**Function: SetProperty(IntoTheCode.CodeElement,System.String,IntoTheCode.Read.ParserStatus)**
    
* Parameter property: CodeElement with property name.
* Parameter value: Value string.
* Parameter status: If error add to this.
* Returns: True: property set. False: not set.<br>*Override this to set a property from grammar.*
    
**Function: ResolveErrorsLast(IntoTheCode.CodeElement,System.Int32)**
    
* Returns: 0: Not found, 1: Found-read error, 2: Found and read ok.

### <a name="IntoTheCode.Read.ParserBuilder">Class: ParserBuilder</a>
(Namespace: IntoTheCode.Read)
<br>*Build Grammar elements for a parser from dokument*
    
**Function: BuildRules(IntoTheCode.Parser,IntoTheCode.CodeDocument,IntoTheCode.Read.ParserStatus)**
    
**Function: InitializeGrammar(IntoTheCode.Parser,System.Collections.Generic.List{IntoTheCode.Read.Structure.Rule},IntoTheCode.Read.ParserStatus)**
    
* Parameter parser: The parser.
* Parameter rules: Set of rules.
* Parameter status: The parser status.
* Returns: True: no error. False: error.<br>*Initialize rules and elements. Called when creating a new parser and when cloning grammar.*
    
**Function: InitializeElements(System.Collections.Generic.IEnumerable{IntoTheCode.Read.ParserElementBase},System.Collections.Generic.List{IntoTheCode.Read.Structure.Rule},IntoTheCode.Read.ParserStatus)**
    
* Parameter elements: Elements to Initialize.
* Parameter rules: Set of rules.
* Parameter status: The parser status.<br>*Initialize rules and elements. Called when creating a new parser and when cloning grammar.*
    
**Function: InitializeResolve(System.Collections.Generic.List{IntoTheCode.Read.Structure.Rule},IntoTheCode.Read.Structure.RuleLink,IntoTheCode.Read.ParserStatus)**
    
* Parameter rules: 
* Parameter link: 
* Parameter status: 
* Returns: <br>*Find the rule to a RuleLink.*
    
**Function: ApplySettingsFromGrammar(IntoTheCode.Parser,IntoTheCode.CodeDocument,IntoTheCode.Read.ParserStatus)**
    
* Returns: <br>*Apply settings to a linked Grammar.*
    
**Function: ValidateGrammar(IntoTheCode.Parser,IntoTheCode.Read.ParserStatus)**
    
* Returns: <br>*Apply settings to a linked Grammar.*
    

### <a name="IntoTheCode.Read.HardElement">Class: HardElement</a>
(Namespace: IntoTheCode.Read)

Inherits [IntoTheCode.TextElement](#IntoTheCode.TextElement)
    <br>*A hard coded element.*
    

### <a name="IntoTheCode.Read.MetaParser">Class: MetaParser</a>
(Namespace: IntoTheCode.Read)
<br>*The meta-grammar for proces grammar definitions. The Instance property is a singleton parser of grammares. This class contains a hard coded parser and a string MetaGrammer, to build rules of the meta parser.*
    
**Property: SoftMetaGrammarAndSettings**
<br>*The meta grammar for proces other grammares.*
    
**Property: MetaGrammar**
<br>*The meta grammar for proces other grammares.*
    
**Property: MetaSettings**
<br>*The settings of meta grammar.*
    
**Constructor()**
    <br>*A linked grammar for EBNF.*
    

### <a name="IntoTheCode.Read.ParserElementBase">Class: ParserElementBase</a>
(Namespace: IntoTheCode.Read)

Inherits [](#)
    <br>*A basic element (or symbol) of a Grammar. Can read a peace of code/text.*
    
**Function: CloneForParse(IntoTheCode.Buffer.TextBuffer)**
    
* Parameter proces: The load proces.
* Returns: The new clone.<br>*Clone this parser element, with sub elements, and set proces.*
    
**Function: SetProperty(IntoTheCode.CodeElement,System.String,IntoTheCode.Read.ParserStatus)**
    
* Parameter property: CodeElement with property name.
* Parameter value: Value string.
* Parameter status: If error add to this.
* Returns: True: property set. False: not set.<br>*Override this to set a property from grammar.*
    
**Function: SetPointerBack(System.Int32)**
    
* Parameter txtPtr: Pointer to set.
* Returns: Always return false.<br>*If the element cant read; use this to reset (set pointer back):*
    
**Function: Load(System.Collections.Generic.List{IntoTheCode.TextElement},System.Int32)**
    
* Parameter outElements: Read elements.
* Parameter level: Level of rules.
* Returns: True = succes.<br>*Load/read an element from the buffer, and increase the buffer pointer if element is ok. Insert output in 'outElements'. If loading fails the buffer pointer must be set back to previus point. The Buffer.Status.UnambiguousPointer is a point of no return. If the buffer pointer is set back before 'UnambiguousPointer'. Errors must be resolved.*
    
**Function: ResolveErrorsLast(IntoTheCode.CodeElement,System.Int32)**
    
* Parameter last: Not null, not empty.
* Parameter level: Level of rules.
* Returns: 0: Not found, 1: Found-read error, 2: Found and read ok.<br>*Find the Rule/ 'read element', that correspond to the last CodeElement, and read it again with error resolving. These recursive functions are initialy called from the parser (or a SetOfElements), when the parsing is failed without any identified errors. The unfinished part of the CodeDocument is used to pin whitch element was the last to succeed AND reestablish a belonging chain of recursive calls. From that point errors is tracked with the LoadTrackError function.*
    
**Function: ResolveErrorsForward(System.Int32)**
    
* Returns: True = no error.<br>*Find errors in following syntax.*
    
**Function: InitializeLoop(System.Collections.Generic.List{IntoTheCode.Read.Structure.Rule},System.Collections.Generic.List{IntoTheCode.Read.ParserElementBase},IntoTheCode.Read.ParserStatus)**
    
* Parameter elem: The element to analyse.
* Parameter path: The path to the element; only rules and RuleLinks.
* Parameter status: 
* Returns: True: one path has an ending.<br>*Find which RuleLinks are recursive. Called by the ParserFactory after Initializing grammar. Each path though the grammar must be followed, and each rule must have an ending.*
    

### <a name="IntoTheCode.TextElement">Class: TextElement</a>
(Namespace: IntoTheCode)

Inherits [](#)
    <br>*The Elements that build up a TextDokument.*
    
**Function: Codes()**
    
* Returns: A enumerable of codes.<br>*Get all child code elements.*
    
**Function: Codes(System.String)**
    
* Parameter name: The name to search for.
* Returns: A enumerable of codes.<br>*Find child code elements with a given name.*
    
**Function: Codes(System.Func{IntoTheCode.CodeElement,System.Boolean})**
    
* Parameter predicate: The predicate to filter with.
* Returns: A enumerable of codes.<br>*Find child code elements with a predicate.*
    

### <a name="IntoTheCode.CommentElement">Class: CommentElement</a>
(Namespace: IntoTheCode)

Inherits [IntoTheCode.CodeElement](#IntoTheCode.CodeElement)
    <br>*Comments from the Text.*
    

### <a name="IntoTheCode.ParserException">Class: ParserException</a>
(Namespace: IntoTheCode)
<br>*Error when the input doesn't match the Grammar.*
    
**Constructor(System.String)**
    
* Parameter msg: The message.<br>*Creator.*
    